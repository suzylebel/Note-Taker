const n=["string","bigint","number","boolean"];function t(n){return Object.entries(n)}function r(n){return Object.values(n)}function e(n){return Object.keys(n)}function o(n){return null!=n}function u(n){return new Promise(t=>setTimeout(t,n))}function c(){}const i=(n,t)=>{let r=null;return(...e)=>{null!==r&&(clearTimeout(r),r=null),r=setTimeout(()=>n(...e),t)}};function f(n){return!("object"!=typeof n||!n)&&n.constructor===Object}function s(t){return n.includes(typeof t)}function l(n){if(null===n||s(n))return n;if(Array.isArray(n)){const t=[];for(const r of n)t.push(l(r));return t}if(f(n)){const t={};for(const[r,e]of Object.entries(n))t[r]=l(e);return t}if(n instanceof Map){const t=new n.constructor;for(const[r,e]of n.entries())t.set(r,l(e));return t}if(n instanceof Set){const t=new n.constructor;for(const r of n.values())t.add(l(r));return t}return n}function a(n,t){return 100*n/t}function h(n,t){return n*t/100}function b(n,t){return t<=0?n:t>=100?0:n-n*(t/100)}function m(n){return n[Math.floor(Math.random()*n.length)]}function g(n,t){if(t<1)throw new RangeError("chunkSize must be 1 or greater.");if(!Number.isInteger(t))throw new TypeError("chunkSize must be an integer.");const r=n.slice(),e=[];for(;r.length;)e.push(r.splice(0,t));return e}function p(n,t){return Math.floor(Math.random()*(t-n+1)+n)}function w(n,t){return Math.random()*(t-n)+n}function d(n){return 1===p(1,n)}function j(n){return w(0,100)<n}export{h as calcPercentOfNum,a as calcWhatPercent,g as chunk,i as debounce,l as deepClone,f as isObject,s as isPrimitive,c as noOp,o as notEmpty,t as objectEntries,e as objectKeys,r as objectValues,j as percentChance,n as primitiveTypes,m as randArrItem,w as randFloat,p as randInt,b as reduceNumByPercent,d as roll,u as sleep};
//# sourceMappingURL=index.es.mjs.map
